
///////////////////////////////////////////
// 题目：共享单车管理系统                     //
// 提交时间：2017.12.31                    //
// 小组名称：Cloudbike                     //
// 小组成员：黄任泽、王骞、陈悦                //
// 数据库管理工具：MySQL                    //
// 系统架构：C/S 结构                       //
///////////////////////////////////////////

0.小组分工：
  黄任泽：1）尝试多种工具与平台，最终指明使用 MySQL 与 C/S 结构等工作方向

	2）程序框架的大致逻辑设计

	3）所要求的数据库相关查询语句，与程序中相应的代码实现

	4）所要求的数据库其他管理员功能，与程序中相应的代码实现

	5）所要求的数据库触发器语句，与程序中相应的代码实现

	6）用户使用过程中与 MySQL 通信的语句，与相应的代码实现

	（注：以上（3）-（6）即对应程序代码中 Mysql.cpp）

	7）README PROGRAM文档

  王 骞：1）编写程序随机生成数据

	2）关系模式的规范与优化

	3）程序框架的详细逻辑设计

	4）程序框架的代码实现

	（注：以上（4）即对应程序代码中 Typedef.h, Main.cpp, User.cpp, Manager.cpp, Function.cpp）

	5）程序代码的调试排错与结构优化

	6）README 文档和 README DETAILS 文档

  陈 悦：1）完成了 E-R 图绘制工作

	2）将 E-R 图改写为原始关系模式表示

	3）制作关系模式表实例展示 EXCEL 文件

	4）程序中生成 XML 文档的代码实现


1.Definition：
	该文件夹下存有我们数据库的设计信息，包括 E-R 图，关系模式，关系模式表（部分实例）。

	（1）Bicycle_ER.pdf：该 pdf 文件是我们设计的 E-R 图。我们设计了三个实体集，分别为 user、bike、order，

	也为它们设置了相应的属性，从它们的命名中可以很容易看出它们代表什么。

	三个实体集之间有两个联系集，分别为 user_order 和 user_bike，这里主要要说明，

	由于 order 与 user 是一对多的关系，order 与 bike 也是一对多的关系，即唯一的订单可以

	唯一确定 user 和 bike，因此 user 和 bike 之间不需要第三个联系集，同样的理由，

	也没有必要将搞出联系集与实体集之间的联系集。或者可以这样说，user 与 bike之间

	的下单关系本身是一个联系集，但是由于同一个用户和同一辆车可以产生多份订单，

	我们将这个联系集改为订单的实体集，这样更为合理，也便于后续的数据库管理。

	（2）关系模式：该 pdf 文件使我们设计的关系模式。在E-R图和关系模式中，下划线标注的均为主码。

	这个关系模式是由 E-R 图直接转化而来，还没有进行规范化，也略去了外码约束。

	（3）build：该文件中使我们最终使用的关系模式，直接用 SQL 语句进行表达。这里指明了我们的数据库系统名称

	为 Cloudbike，共创建了四个表。user、bike、order 表都是显然的，而 location 表的出现是规范化的

	结果，为了减少冗余，我们将 user、bike、order 中的行政区与街道信息提取出来，单独创建一个表

	进行存储。我们曾经试图将经纬度也纳入到 location 中，最后发现这样会导致 location 表过大，因此

	我们放弃了这种想法，longitude 和 latitude 属性仍然存储在其他三个表中。由于 order 和 user、bike

	的一对多的关系，联系集所生成的关系模式也是冗余部分，因此我们舍去了两个联系集生成的关系。

	我们在这里申明了主码和外码约束，均使用 ID 作为名称，易于辨认。

	（4）xlsx：其余四个 excel 文件给出了关系模式表，以数据实例的形式进行展现，其中列出的正是我们生成数据中

	每个关系的前十五行。

2.Dataset：
	该文件夹下存有我们的数据，分别是四个表的数据，同样以 SQL 语句进行表达。我们共生成了 1000 个用户，

	10000 辆共享单车，10000 个历史订单，121 个地点。这里我们介绍一下我们的地图设定。我们的地图范围将

	限定在海淀区，数据中随机生成的经纬度大部分在 [116.1, 116.3], [39.9, 40.1] 区间内，与海淀区的实际

	经纬度大致符合。我们使用的街道名取自海淀区真实的街道名，但是具体位置并不是实际位置。我们假设

	海淀区是一块正方形区域，共有 11 条东西走向的街道，11 条南北走向的街道，街道之间间距相同。这样每个

	用户和车辆的（或订单记录的）位置就不是一条街道，而是两条街道，代表着位于在两条街道交叉路口附近。

	在生成数据的时候我们也保证生成的经纬度符合我们的地图假设。我们随机生成字符串当做用户的账户名、

	昵称、密码、工作，性别限定在 male 和 female，state_user 均为 0 代表没有用户正在骑行。共享单车具有类

	型，取自实际单车的类型，分别有着各自的单价，state_bike 均为 0 代表没有车辆正在骑行，broken 表示车辆

	是否损坏，生成数据中我们设定了一定比例的坏车。我们随机生成了历史订单记录，并保证这些订单记录

	满足外码约束等要求。我们附上我们随机生成数据的代码和程序，但是建议最好不要经常去运行它，因为

	每次运行会导致数据发生改变，我们不认为重新随机出的数据会有什么不利影响，只是没有必要这样做。

3.make：
	出于我们设计与调试数据库的方便，我们写了一个 make 文件，例如：make 文件现在位于 D:/Cloudbike 文件夹中，

	那么可以在MySQL中直接输入：\. D:/Cloudbike/make 即可完成数据库从创建到插入数据的一系列工作。

	但如果路径不同的话，不仅指令不同，还需要在 make 文件中相应修改一些路径。我们建议使用者使用 make 这个

	文件，因为它确实会给数据库的准备带来方便。

4.Code：
	这里存有我们的程序代码，除去生成 xml 所需要的若干代码外，有 Typedef.h, Main.cpp, Manager.cpp, 

	User.cpp, Mysql.cpp, Function.cpp。Typedef.h 中包括了可能用到的头文件、用户结构、管理员操作相关

	函数声明，MySQL 相关函数声明，其他函数声明。与用户相关的函数体均放在 User.cpp 中，与管理员相关的

	函数体均放在 Manager.cpp 中，与 MySQL 通信有关的函数体均放在 Mysql.cpp 中，程序需要用到的其他函数体

	放在 Function.cpp 中。如果编译的话，可能需要修改的有，头文件中操作系统部分，本地 MySQL 的用户与密码。

	当然，要连接 MySQL 也需要设置合适的编译环境，包含必要的库和文件等。我们主要使用 vs 软件进行编译，

	在 Windows 和 Ubuntu 上都是可以编译成功的。我们没有提交程序，因为提交的程序很有可能因为环境、路径、

	mysql 账户密码配置路径等原因无法使用。在登陆界面正常登录会注册会进入用户使用界面，输入特定的

	管理员账号和密码则会进入管理员界面，我们在程序中加入了丰富的输出提示。代码结构的详细说明参见

	README PROGRAM.txt。

5.Output：
	该文件夹中存有一些输出，包括所要求查询的 SQL 语句、查询结果，XML 输出。

